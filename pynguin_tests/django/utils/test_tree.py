# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import tree as module_0
import django.utils.hashable as module_1


def test_case_0():
    bytes_0 = b"\xc4\xb2\x93`\xf9Rs6\xf0\xf2\xcf\xb0nL6\xa7\x10\x02"
    node_0 = module_0.Node(bytes_0, bytes_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__str__()
    assert (
        var_0
        == "(b'\\xc4\\xb2\\x93`\\xf9Rs6\\xf0\\xf2\\xcf\\xb0nL6\\xa7\\x10\\x02': 196, 178, 147, 96, 249, 82, 115, 54, 240, 242, 207, 176, 110, 76, 54, 167, 16, 2)"
    )
    none_type_0 = None
    node_1 = module_0.Node(none_type_0)


def test_case_1():
    int_0 = 459
    bool_0 = True
    bool_1 = True
    tuple_0 = (int_0, bool_0, bool_1)
    node_0 = module_0.Node(tuple_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )


@pytest.mark.xfail(strict=True)
def test_case_2():
    node_0 = module_0.Node()
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__bool__()
    var_1 = node_0.add(node_0, var_0)
    assert len(node_0) == 2
    assert f"{type(var_1).__module__}.{type(var_1).__qualname__}" == "tree.Node"
    assert len(var_1) == 2
    node_0.__str__()


def test_case_3():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    node_1 = module_0.Node()
    var_0 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    var_1 = node_1.__deepcopy__(var_0)
    assert len(var_1) == 2
    var_2 = node_1.add(node_0, node_0)
    assert len(node_1) == 3
    assert len(var_2) == 0


def test_case_4():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    node_1 = module_0.Node()
    var_0 = node_1.__copy__()
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    var_1 = var_0.negate()
    var_2 = node_1.__copy__()
    var_3 = var_0.__str__()
    assert var_3 == "(NOT (DEFAULT: ))"
    var_4 = var_0.__hash__()
    assert var_4 == 2241940934919080915
    var_5 = node_1.add(var_3, var_3)
    assert var_5 == "(NOT (DEFAULT: ))"
    assert len(node_1) == 2
    node_2 = var_1.__str__()
    var_6 = var_2.negate()


def test_case_5():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    node_1 = module_0.Node()
    var_0 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    var_1 = node_1.add(node_0, node_0)
    assert len(node_1) == 3
    assert len(var_1) == 0


@pytest.mark.xfail(strict=True)
def test_case_6():
    none_type_0 = None
    var_0 = module_1.make_hashable(none_type_0)
    var_0.__copy__()


def test_case_7():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    node_1 = module_0.Node()
    var_0 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    var_1 = node_1.add(node_0, node_0)
    assert len(node_1) == 3
    assert len(var_1) == 0
    var_2 = node_0.__repr__()
    assert var_2 == "<Node: (DEFAULT: )>"


def test_case_8():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    node_1 = module_0.Node()
    var_0 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    node_2 = module_0.Node(negated=var_0)
    var_1 = node_1.add(node_0, node_0)
    assert len(node_1) == 3
    assert len(var_1) == 0
    var_2 = none_type_0.__hash__()
    str_0 = "\x0cl<J|[y{U`=<`qFp,Ck"
    var_3 = node_2.__eq__(str_0)
    var_4 = node_1.__contains__(var_0)
    assert var_4 is True


def test_case_9():
    none_type_0 = None
    node_0 = module_0.Node(connector=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__copy__()
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    var_1 = var_0.__hash__()
    assert var_1 == 7135014963891777281


@pytest.mark.xfail(strict=True)
def test_case_10():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.add(none_type_0, none_type_0)
    assert len(node_0) == 2
    node_1 = module_0.Node()
    node_2 = module_0.Node()
    var_1 = node_1.add(none_type_0, node_2)
    assert len(node_1) == 2
    var_2 = node_1.__copy__()
    assert len(var_2) == 2
    var_3 = var_2.__deepcopy__(var_1)
    assert len(var_3) == 2
    var_4 = var_3.negate()
    var_5 = var_3.__contains__(node_1)
    assert var_5 is False
    var_6 = node_1.__deepcopy__(var_4)
    assert len(var_6) == 2
    var_7 = var_4.__hash__()
    var_8 = var_7.__repr__()
    var_4.__contains__(none_type_0)


def test_case_11():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__copy__()
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    node_1 = module_0.Node()
    var_1 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    node_2 = module_0.Node(negated=var_1)
    var_2 = node_0.__copy__()
    var_3 = node_1.add(var_2, var_2)
    assert len(node_1) == 3
    assert len(var_3) == 0
    var_4 = none_type_0.__hash__()
    str_0 = "\x0cl<J|[y{U`=<`qFp,Ck"
    var_5 = node_2.__eq__(str_0)
    var_6 = node_1.__contains__(var_3)
    assert var_6 is True


def test_case_12():
    none_type_0 = None
    node_0 = module_0.Node(none_type_0, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__copy__()
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    node_1 = module_0.Node()
    var_1 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    var_2 = node_0.__len__()
    var_3 = node_1.add(var_1, node_0)
    assert len(node_1) == 3
    node_2 = module_0.Node(negated=var_2)
    var_4 = node_0.__copy__()
    var_5 = node_1.add(var_4, var_4)
    assert len(node_1) == 4
    assert len(var_5) == 0
    var_6 = var_3.__hash__()
    var_7 = node_0.__repr__()
    assert var_7 == "<Node: (DEFAULT: )>"
    var_8 = node_2.__eq__(var_2)
    var_9 = node_1.__contains__(var_1)
    assert var_9 is True


@pytest.mark.xfail(strict=True)
def test_case_13():
    none_type_0 = None
    none_type_1 = None
    node_0 = module_0.Node(none_type_1, negated=none_type_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__deepcopy__(none_type_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    node_1 = module_0.Node()
    var_1 = node_1.add(none_type_0, node_0)
    assert len(node_1) == 2
    var_2 = node_1.__len__()
    assert var_2 == 2
    var_3 = node_1.__repr__()
    assert var_3 == "<Node: ((DEFAULT: ): (DEFAULT: ), None)>"
    var_4 = node_0.negate()
    node_2 = module_0.Node(negated=var_2)
    var_5 = node_0.__copy__()
    var_6 = none_type_0.__hash__()
    var_7 = var_2.__hash__()
    assert var_7 == 2
    var_8 = node_1.add(var_5, var_5)
    assert len(node_1) == 3
    assert len(var_8) == 0
    var_2.negate()


@pytest.mark.xfail(strict=True)
def test_case_14():
    none_type_0 = None
    none_type_1 = None
    dict_0 = {
        none_type_1: none_type_1,
        none_type_1: none_type_0,
        none_type_1: none_type_1,
    }
    node_0 = module_0.Node(connector=dict_0)
    assert module_0.Node.default == "DEFAULT"
    assert (
        f"{type(module_0.Node.create).__module__}.{type(module_0.Node.create).__qualname__}"
        == "builtins.method"
    )
    var_0 = node_0.__deepcopy__(none_type_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "tree.Node"
    assert len(var_0) == 0
    bytes_0 = b"\xd0\xb5-\xf4\xe9\xeaP"
    node_1 = module_0.Node()
    var_1 = node_0.add(node_0, dict_0)
    assert len(var_1) == 0
    var_2 = node_0.__len__()
    assert var_2 == 0
    var_3 = var_1.add(none_type_0, var_1)
    assert len(node_0) == 2
    assert len(var_1) == 2
    node_2 = module_0.Node(connector=bytes_0)
    var_4 = node_1.__copy__()
    var_5 = var_4.__hash__()
    assert var_5 == 7135014963891777281
    var_6 = node_2.__hash__()
    assert var_6 == 5671418149701420223
    var_3.add(var_3, var_1)
